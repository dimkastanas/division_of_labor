// webppl RR_simulations.wppl 
var contexts = [
  {
    target: "two small green square",
    neutral: ["two small green circle", "one small green star"],
    competitor: ["two small blue square", "one small blue triangle"],
    alternative: ["two small green square", "one small green pentagon"],
  },
];

// subset of possible utterances
var possibleUtterances = Categorical({
  vs: [
    // references to the target
    "two small green square",
    "small green square",
    "green square",
    "two small",
    "small green",
    "green",
    "square",

    // references to the competitor, alternative and neutral
    "circle",
    "two small green circle",
    "blue square",
    "two small blue square",
    "pentagon",
    "two small green pentagon",

    // references using only
    "small only",
    "green only",
    "square only",
    "circle only",
    "two small green square only",
  ],
});

var possibleObjects = Categorical({
  vs: map(function (v) {
    return v["target"];
  }, contexts),
});

// these are the possible mixture weights for perspective-taking
// where 0 is purely egocentric and 1 is purely partner's perspective
var possibleWeightings = Categorical({
  vs: _.range(0, 1, 0.1),
});

// alpha: soft-max temperature
// <feature>Cost: cost associated with producing this feature
// perspectiveCost: cost associated with perspective-taking
var params = {
  alpha: 3,
  costWeight: 0.02,
  perspectiveCost: 0,
};

// when the utterance is true
var meaning = function (utt, object) {
  var descriptors = utt.split(" ");
  var objProperties = object.split(" ");

  // property categories
  var categories = {
    shapes: ["circle", "square", "triangle", "pentagon", "star"],
    colours: ["green", "pink", "black", "blue"],
    sizes: ["small", "big"],
    numbers: ["two", "one"]
  };

  // if "only" was in utterance, check exhaustivity
  if (_.includes(descriptors, "only")) {
    descriptors = _.without(descriptors, "only");
    return _.every(descriptors, descriptor => {
      var category = _.findKey(categories, values => _.includes(values, descriptor));
      return !category || _.intersection(objProperties, categories[category]).length === 1;
    });
  }

  // simple case: just check if all descriptors exist in object properties
  return _.every(descriptors, d => _.includes(objProperties, d));
};

var getTrueUtterances = function (context) {
  var trueUtts = filter(function (utt) {
    return _.some(
      map(function (obj) {
        return meaning(utt, obj);
      }, context)
    );
  }, possibleUtterances.support());
  return Categorical({ vs: trueUtts });
};

// cost of producing utterance is sum of costs of the component words
var uttCost = function (utt) {
  return params.costWeight * utt.split(" ").length;
};

// derives the speaker's perspective from the listener's visible context
var getSpeakerView = function (listenerContext) {
  var hiddenObj = find(function (x) {
    return last(x.split(" ")) == "private";
  }, listenerContext);
  return remove(hiddenObj, listenerContext);
};

// L0 interprets utterance literally using fixed mixture of perspectives
var L0 = cache(function (utt, context, weighting) {
  return Infer({ method: "enumerate" }, function () {
    var perspective = flip(weighting) ? "other" : "own";
    var partnerContext =
      perspective == "own" ? context : getSpeakerView(context);
    var object = uniformDraw(partnerContext);
    factor(meaning(utt, object, partnerContext) ? Math.log(1) : Math.log(0.01));
    return object;
  });
});

// S1 selects utterance using fixed mixture of perspectives
// (given belief about L0's mixture)

var S1 = cache(function (target, context, ownWeighting) {
  return Infer({ method: "enumerate" }, function () {
    var utt = sample(getTrueUtterances(context));
    var egocentricUtility =
      L0(utt, context, 0).score(target) - uttCost(utt, params);
    var combinedUtility = expectation(
      possibleWeightings,
      function (partnerWeighting) {
        var asymmetricUtility = expectation(possibleObjects, function (obj) {
          var possibleListenerView = context.concat(obj + " private");
          return (
            L0(utt, possibleListenerView, partnerWeighting).score(target) -
            uttCost(utt, params)
          );
        });
        return (
          ownWeighting * asymmetricUtility +
          (1 - ownWeighting) * egocentricUtility
        );
      }
    );
    factor(params.alpha * combinedUtility);
    return utt;
  });
});

// L1 selects objects given belief about S1's mixture
var L1 = function (utt, context, ownWeighting) {
  return Infer({ method: "enumerate" }, function () {
    var perspective = flip(ownWeighting) ? "other" : "own";
    var partnerContext =
      perspective == "own" ? context : getSpeakerView(context);
    var partnerWeight = perspective == "own" ? 0 : sample(possibleWeightings);

    var object = uniformDraw(partnerContext);
    observe(S1(object, partnerContext, partnerWeight), utt);
    return object;
  });
};

// meta-cognitive resource-rational speaker selects optimal mixture
// weight, marginalizing over uncertainty about listener's weight
var RR_speaker = function (target, context) {
  return Infer({ method: "enumerate" }, function () {
    var ownWeighting = sample(possibleWeightings);

    // Imagine how speaker with this weight would behave
    var likelyUtt = MAP(S1(target, context, ownWeighting))["val"];
    console.log(likelyUtt);
    // Imagine expected utility of that behavior, marginalizing over
    // partner's mixture weight and possible objects in partner's view
    var utility = expectation(possibleObjects, function (obj) {
      return expectation(possibleWeightings, function (partnerWeighting) {
        var possibleListenerView = context.concat(obj + " private");
        return L0(likelyUtt, possibleListenerView, partnerWeighting).score(
          target
        );
      });
    });
    console.log(utility);
    // putting more weight on partner's perspective is costly
    factor(utility - ownWeighting * params.perspectiveCost);
    return {
      weighting: ownWeighting,
      perspectiveCost: params.perspectiveCost,
      alpha: params.alpha,
      //uttCost: argv.uttCost,
    };
  });
};

// meta-cognitive resource-rational speaker selects optimal mixture
// weight, marginalizing over uncertainty about listener's weight
var RR_listener = function (utt, baseContext) {
  return Infer({ method: "enumerate" }, function () {
    var ownWeighting = sample(possibleWeightings);

    // Marginalize over partner's mixture weight and possible hidden objects
    var utility = expectation(possibleObjects, function (hiddenObj) {
      return expectation(possibleWeightings, function (partnerWeighting) {
        var context = baseContext.concat(hiddenObj + " private");
        var realSpeakerView = getSpeakerView(context);
        var worstCaseTarget = last(realSpeakerView);
        var likelyUtt = MAP(
          S1(worstCaseTarget, realSpeakerView, partnerWeighting)
        )["val"];
        return L1(likelyUtt, context, ownWeighting).score(worstCaseTarget);
      });
    });

    // putting more weight on partner's perspective is costly
    factor(utility - ownWeighting * params.perspectiveCost);
    return {
      weighting: ownWeighting,
      perspectiveCost: params.perspectiveCost,
      alpha: params.alpha,
      //uttCost: argv.uttCost,
    };
  });
};

// Test cases for meaning function
console.log("Testing meaning function:");
console.log("-----------------------");

// Basic tests (without "only")
console.log("Basic tests:");
console.log("1. 'circle' in 'two small green square' ->", meaning("circle", "two small green square")); // should be false
console.log("2. 'small green' in 'two small green square' ->", meaning("small green", "two small green square")); // should be true
console.log("3. 'two small' in 'two small green square' ->", meaning("two small", "two small green square")); // should be true
console.log("4. 'green square' in 'two small green square' ->", meaning("green square", "two small green square")); // should be true
console.log("5. 'big' in 'two small green square' ->", meaning("big", "two small green square")); // should be false

// Exhaustivity tests (with "only")
console.log("\nExhaustivity tests:");
console.log("1. 'small only' in 'two small green square' ->", meaning("small only", "two small green square")); // should be true (only one size)
console.log("2. 'green only' in 'two small green square' ->", meaning("green only", "two small green square")); // should be true (only one color)
console.log("3. 'square only' in 'two small green square' ->", meaning("square only", "two small green square")); // should be true (only one shape)
console.log("4. 'small only' in 'two small green square small' ->", meaning("small only", "two small green square small")); // should be false (multiple sizes)
console.log("5. 'green only' in 'two small green square green' ->", meaning("green only", "two small green square green")); // should be false (multiple colors)
console.log("6. 'square only' in 'two small green square circle' ->", meaning("square only", "two small green square circle")); // should be false (multiple shapes)

// Edge cases
console.log("\nEdge cases:");
console.log("1. Empty utterance ->", meaning("", "two small green square")); // should be true
console.log("2. Empty object ->", meaning("small", "")); // should be false
console.log("3. 'only' by itself ->", meaning("only", "two small green square")); // should be true
console.log("4. Non-category word with 'only' ->", meaning("hello only", "two small green square")); // should be true (non-category words don't need exhaustivity)
